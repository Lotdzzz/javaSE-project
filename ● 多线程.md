# ● 多线程

**单线程：**
就你一个人干，必须先洗完菜才能切菜，切完菜才能炒菜，炒完菜才能煮米饭，一步接一步，全程只有一个 “干活的人”，效率很低。

**多线程：**
你喊上爸妈一起干 —— 你洗菜（线程 1）、爸妈切菜（线程 2）、同时电饭煲煮米饭（线程 3），这三个 “干活的任务”同时进行，整体做饭速度直接翻倍。

**放到 Java 里：**

 - 进程：可以理解为 “整个做饭的厨房”（一个运行的 Java 程序就是一个进程）；
 - 线程：就是厨房里面 “干活的人”（线程是程序里最小的执行单元）；
 - 主线程：Java 程序运行时，默认会有一个main线程（就像默认只有你一个人进厨房干活）；
 - 多线程：就是你在程序里手动创建多个 “干活的人”，让它们同时执行不同的任务。
 - 并发：多人 “交替” 干不同活（你切菜时我洗菜，轮流用菜刀）	多个线程在同一 CPU上交替执行（CPU 切换快，看起来像同时）
 - 并行（Parallelism）	多人 “同时” 干不同活（你切菜、我洗菜，各用一把刀）	多个线程在多个 CPU 核心上同时执行（真正的同时）
 - 并发和并行可能同时发生
 - 共享资源：多线程争抢的 “公共物品”（菜刀、电饭煲）	多个线程共同访问的变量、对象、文件等数据（线程安全问题的根源)

> **当你的线程数量 > CPU 核心数 时，就会出现「混合模式」。 比如：你的电脑是8 核 CPU，你用线程池开了10 个线程 → 同一时间，8 个线程在 8 个 CPU 核心上「并行执行」（真同时）； 剩下的2 个线程，在 CPU 的核心上「并发执行」（交替切换）；
> 整体就是「并发 + 并行」混合，这是最常见的情况。**

## ○ 线程生命周期

- 新建（New）：创建了 Thread 对象，但还没调用start()（比如 “找好了人，但还没喊他干活”）；
 - 就绪（Runnable）：调用start()后，线程等待 CPU 调度（“人站好队，等分配任务”）；
 - 运行（Running）：CPU 选中线程，执行run()方法（“人正在干活”）；
 - 阻塞（Blocked/Waiting/Timed_Waiting）：线程暂时停止执行，让出 CPU（“人临时停活，比如等菜刀、休息 5 分钟”）；
 - - - Timed_Waiting：有时间限制的阻塞（sleep(1000)、wait(1000)）；
 - - -  Waiting：无时间限制的阻塞（wait()、join()）；
 - - -  Blocked：等待获取锁的阻塞（比如抢synchronized锁）；
 - 终止（Terminated）：run()执行完或异常终止（“人干完活下班了”）。

图来自[www.itheima.com]
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/d2a344495efc48bea26bf9b95080420d.png)

## ○ 线程实现

**1：基于继承Thread类实现（比较简单，但只能单继承）：**

```java
// 1. 继承Thread类，重写run()（定义要干的活）
class MyThread extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            // Thread.currentThread().getName() 获取当前线程名
            System.out.println(Thread.currentThread().getName() + " 执行：" + i);
            try {
                Thread.sleep(300); // 模拟耗时
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

public class ThreadCreate1 {
    public static void main(String[] args) {
        // 2. 创建线程对象（新建状态）
        MyThread t1 = new MyThread();
        MyThread t2 = new MyThread();
        // 给线程起名，方便调试
        t1.setName("线程1");
        t2.setName("线程2");
        
        // 3. 启动线程（就绪状态）
        t1.start(); 
        t2.start();
    }
}
```

**2：基于实现Runnable接口实现（无继承限制）：**

```java
public void start() {
        Runnable r1 = () -> {
            //设置线程名字
            Thread.currentThread().setName("Run One");
            for (int i = 0; i < 100; i++) {
                //获取线程名字
                System.out.println(Thread.currentThread().getName() + i);
            }
        };

        Runnable r2 = () -> {
            for (int i = 0; i < 100; i++) {
                System.out.println(Thread.currentThread().getName() + i);
            }
        };
        new Thread(r1).start();
        new Thread(r2).start();
    }
```

**3：基于实现Callable接口实现(带返回值 + 可抛异常)：**
前两种方式的run()没有返回值、不能抛检查异常，Callable 解决了这个问题，需要配合FutureTask使用：

```java
public void start() throws ExecutionException, InterruptedException {
        //lambda创建Callable
        Callable<Integer> callable = () -> {
            int sum = 0;
            for (int i = 0; i < 100; i++) {
                sum += i;
            }
            return sum;
        };
        //配合FutureTask使用
        FutureTask<Integer> futureTask = new FutureTask<>(callable);
        //执行线程
        Thread thread = new Thread(futureTask);
        thread.start();
        //通过FutureTask获取线程返回值
        Integer i = futureTask.get();
        System.out.println(i);
    }
```

**线程常用方法：**

 - String getName()：返回此线程的名称
 - void setName(String name）：设置线程的名字(构造方法也可以设置名字)
 - static Thread currentThread()：获取当前线程的对象
 - static void sleep(long time)：让线程休眠指定的时间，单位为毫秒
 - setPriority(int newPriority)：设置线程的优先级1~10越大抢cpu概率越高，默认为5
 - final int getPriority()：获取线程的优先级
 - final void setDaemon(boolean on)：设置为守护线程
 - public static void yield()：出让线程/礼让线程
 - public static void join()：插入线程/插队线程

### △ 守护线程

把 Java 程序的运行想象成一家餐厅：

- 用户线程：就是来餐厅吃饭的「顾客」，是餐厅存在的核心意义；
- 守护线程：就是餐厅的「服务员 / 保洁员」，专门为顾客服务，没有顾客了，服务员也就没必要留在餐厅了。

核心逻辑：只要餐厅里还有哪怕 1 个顾客（用户线程），服务员（守护线程）就必须继续工作；
但当最后 1 个顾客离开（所有用户线程结束），餐厅就会关门（JVM 退出），不管服务员的活有没有干完，都会被 “强制下班”（守护线程被终止）。

**用户线程：**
也叫非守护线程，是程序的核心业务线程（比如 main 线程、处理订单的业务线程），只要有一个用户线程还在运行，JVM 就不会退出；

**守护线程：**
为用户线程提供「辅助服务」的线程，它的生命周期完全依赖用户线程 —— 当所有用户线程执行完毕，JVM 会直接终止所有守护线程，然后退出。

```java
public void start() throws ExecutionException, InterruptedException {
        //lambda创建Callable
        Callable<Integer> callable = () -> {
            Thread.currentThread().setName("用户线程");
            int sum = 0;
            for (int i = 0; i < 10; i++) {
                System.out.println(Thread.currentThread().getName() + "@" + i);
                sum += i;
            }
            return sum;
        };

        Callable<Integer> callable2 = () -> {
            Thread.currentThread().setName("守护线程");
            int sum = 0;
            for (int i = 0; i < 1000; i++) {
                System.out.println(Thread.currentThread().getName() + "@" + i);
                sum += i;
            }
            return sum;
        };
        
        
        //配合FutureTask使用
        FutureTask<Integer> futureTask = new FutureTask<>(callable);
        FutureTask<Integer> futureTask2 = new FutureTask<>(callable2);
        
        //执行线程
        Thread thread = new Thread(futureTask);
        Thread thread2 = new Thread(futureTask2);

        thread2.setDaemon(true);

        thread.start();//执行完之后
        thread2.start();//当用户线程执行完后守护线程并不会执行到结束而是执行几次后很快结束线程
    }
```

ps：如果在线程实现方法里设置守护线程则会直接无效，因为守护线程是要在.start()方法执行之前设置才会生效，当在实现方法内设置，调用start()方法时再设置守护线程就已经晚了，会抛出IllegalThreadStateException异常如果不捕获则默认吞线程

### △ 礼让线程

**把线程争抢 CPU 执行权的过程，比作一群人抢唯一的麦克风唱歌：**
CPU 就像这只麦克风，谁拿到谁就能 “表演”（线程执行）；

正常情况：大家疯抢，麦克风在谁手里，谁就一直唱，直到唱完或者被 CPU 强制打断；

yield()的作用：某个抢到麦克风的人，主动说 “我先让一让，你们再抢一次”，然后把麦克风放下，回到抢麦的人群里；

**关键：**
这只是 “礼让”，不是 “让贤”—— 他只是重新加入竞争，最终麦克风落谁手里，还是看现场的调度（比如谁手快、或者主持人（操作系统）偏向谁），有可能他刚让完，又抢到了麦克风继续唱。

```java
public void start() throws ExecutionException, InterruptedException {
        //lambda创建Callable
        Callable<Integer> callable = () -> {
            Thread.currentThread().setName("主线程");
            int sum = 0;
            for (int i = 0; i < 10; i++) {
                System.out.println(Thread.currentThread().getName() + "@" + i);
                sum += i;
            }
            return sum;
        };

        Callable<Integer> callable2 = () -> {
            Thread.currentThread().setName("礼让线程");
            //设置礼让线程
            //表示让出当前cpu执行权
            Thread.yield();
            int sum = 0;
            for (int i = 0; i < 10; i++) {
                System.out.println(Thread.currentThread().getName() + "@" + i);
                sum += i;
            }
            return sum;
        };


        //配合FutureTask使用
        FutureTask<Integer> futureTask = new FutureTask<>(callable);
        FutureTask<Integer> futureTask2 = new FutureTask<>(callable2);

        //执行线程
        Thread thread = new Thread(futureTask);
        Thread thread2 = new Thread(futureTask2);

        thread.start();
        thread2.start();
    }
```

### △ 插入线程

**把线程的执行过程比作银行窗口排队办事：**

你（main线程）是排在窗口前的第一个人，马上就要办理业务；

突然你的朋友（threadA线程）跑过来，说有急事要先办 —— 这就是调用threadA.join()；

核心效果：你（main线程）会主动退到队伍后面，等朋友（threadA）办完所有业务，你才重新回到窗口继续办自己的事；

额外场景：如果朋友说 “我最多占用窗口 5 分钟，5 分钟后不管办完没办完，都该你办”—— 这就是threadA.join(5000)（带超时的 join）。

简单说：join()就是让当前线程“暂停执行”，优先让调用join()的线程 “插队” 执行，等插队的线程执行完（或超时），当前线程才继续。

```java
public static void main(String[] args) throws InterruptedException {
        // 1. 创建一个“急事线程”（模拟要插队的朋友）
        Thread urgentThread = new Thread(() -> {
            Thread.currentThread().setName("急事线程");
            for (int i = 1; i <= 5; i++) {
                try {
                    Thread.sleep(500); // 模拟办事需要时间
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "：正在办第" + i + "件急事");
            }
            System.out.println(Thread.currentThread().getName() + "：所有急事办完了！");
        });

        System.out.println("=== 场景1：不用join（不插队）===");
        urgentThread.start();
        // main线程不等，自己直接执行
        for (int i = 1; i <= 3; i++) {
            Thread.sleep(500);
            System.out.println("main线程：我在办自己的事，第" + i + "件");
        }

        // 等待所有线程执行完，再演示场景2
        Thread.sleep(3000);
        System.out.println("\n=== 场景2：用join（插队）===");
        
        // 重新创建一个急事线程（避免复用已结束的线程）
        Thread urgentThread2 = new Thread(() -> {
            Thread.currentThread().setName("急事线程2");
            for (int i = 1; i <= 5; i++) {
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "：正在办第" + i + "件急事");
            }
            System.out.println(Thread.currentThread().getName() + "：所有急事办完了！");
        });

        urgentThread2.start();
        // 核心：main线程调用join()，让急事线程2插队
        urgentThread2.join(); // 无参join：等急事线程2完全执行完
        // （如果想测试超时：urgentThread2.join(2000); // 只等2秒，不管对方完没办完）
        
        // 只有等急事线程2办完，main线程才会执行下面的代码
        for (int i = 1; i <= 3; i++) {
            Thread.sleep(500);
            System.out.println("main线程：我终于能办自己的事了，第" + i + "件");
        }
    }
```

## ○ 线程安全

**什么是线程安全？**
多个线程同时操作共享资源（比如一个全局变量）时，执行结果不符合预期（比如卖票超卖、计数错误）。

先看问题：

```java
public class MyThread implements Runnable {

    private static int ticket = 100;

    @Override
    public void run() {
        while (true) {
            if (ticket <= 0) {
                break;
            } else {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                System.out.println(Thread.currentThread().getName() + "卖" + ticket--);
            }
        }
    }
}
```

测试：

```java
public void synchronizedTest() {
        Thread t1 = new Thread(new MyThread());
        t1.setName("窗口one");
        Thread t2 = new Thread(new MyThread());
        t2.setName("窗口two");
        Thread t3 = new Thread(new MyThread());
        t3.setName("窗口three");
        t1.start();
        t2.start();
        t3.start();
    }
```

结果：

```go
....
窗口two卖5
窗口three卖5
窗口one卖5
窗口three卖4
窗口two卖3
窗口one卖2
窗口two卖1
窗口three卖1
窗口one卖0
```

`这样线程会出现数据错乱`
**根本原因**

 - 原子性：一个操作（比如count++）不能被拆分，要么全执行，要么全不执行；count++实际是读取→加1→写入三步，多线程下会被拆分；
 - 可见性：一个线程修改了共享变量，其他线程能立刻看到修改后的值；
 - 有序性：程序执行顺序按代码顺序来（JVM 会指令重排，单线程没问题，多线程可能乱序）。

### △ 线程锁

线程锁的核心作用

在多线程场景下，多个线程同时操作共享资源（比如一个变量、一个对象）时，会因为操作的 “非原子性” 导致结果错误（比如卖票超卖、计数不准）。

线程锁的本质：给共享资源加 “访问限制”，让同一时间只有确定的的线程能操作它，从而保证线程安全的原子性。

 - 实现层面	内置锁（synchronized）、显式锁（Lock 接口：ReentrantLock、ReentrantReadWriteLock 等）
 - 锁的特性	可重入锁、公平锁 / 非公平锁、独占锁 / 共享锁、乐观锁 / 悲观锁、自旋锁、偏向锁 / 轻量级锁 / 重量级锁
 - 锁的范围	对象锁、类锁

### △ synchronized锁

**基础锁：synchronized（内置锁 / 监视器锁）**
synchronized 的核心原理：

 - 线程获取锁：关联到对象的 Monitor，标记为 “占用”；
 - 线程释放锁：解除与 Monitor 的关联，标记为 “空闲”；
 - 其他线程抢锁：如果锁被占用，进入等待队列，直到锁释放。

Monitor（锁监视器）就相当于一个锁的门卫，当某个对象被定义为锁之后，就会自动配一个Monitor监视器，如果某个线程抢到了这把锁，门卫会关门不让其他人进来，直到锁被释放

synchronized使用：

 - 使用的锁必须是唯一的比如this XXX.class 或者被static final 修饰的Object对象
 - 多个线程调用同一个对象的该方法时，会互斥；调用不同对象的该方法时，不互斥。
 - 当synchronized修饰非静态方法时默认使用this 反之则是XXX.class

synchronized 的核心特性：

 - ✅ 可重入：同一个线程可以多次获取同一把锁（比如递归调用 synchronized 方法，不会死锁）；
 - ✅ 非公平：锁释放后，等待队列中的线程不按 “先来后到” 抢锁（默认，效率更高）；
 - ✅ 独占锁：同一时间只有一个线程能获取锁；
 - ✅ 自动释放：线程执行完代码块 / 方法，或抛出异常时，会自动释放锁（无需手动操作）。

ps：

```java
public void run() {
        while (true) {
            // synchronized锁不能写在循环之外 否则当某一线程抢到该锁 则会执行完本循环之后再释放锁 程序会单一进程
            synchronized (this) {
                if (ticket <= 0) {
                    break;
                } else {
                    try {
                        Thread.sleep(500);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    System.out.println(Thread.currentThread().getName() + "卖" + ticket--);
                }
            }
        }
    }
```

```java
private static final Object lock = new Object();

    @Override
    public void run() {
        while (true) {
            //自定义锁 只要是static final修饰的唯一对象即可
            synchronized (lock) {
                if (ticket <= 0) {
                    break;
                } else {
                    try {
                        Thread.sleep(500);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    System.out.println(Thread.currentThread().getName() + "卖" + ticket--);
                }
            }
        }
    }
```

### △ Lock锁

 **进阶锁Lock 接口（显式锁）**
 synchronized虽然简单，但功能有限（无法中断、无法超时、无法公平锁），JDK 1.5 引入java.util.concurrent.locks.Lock接口，提供更灵活的显式锁。

Lock 接口的核心方法：

 - lock()	获取锁（阻塞，直到获取到锁）
 - lockInterruptibly()	获取锁，可被中断（线程调用 interrupt () 时，抛 InterruptedException 并退出）
 - tryLock()	尝试获取锁（非阻塞，立即返回 true/false）
 - tryLock(long time, TimeUnit unit)	超时获取锁（在指定时间内获取到返回 true，否则 false）
 - unlock()	释放锁（必须手动调用，推荐放 finally 块）
 - newCondition()	创建条件变量（实现线程间精准通信）

**核心实现类 1：ReentrantLock（可重入锁）**
基本用法（必须记：lock () 放开头，unlock () 放 finally）
ReentrantLock是 Lock 接口最常用的实现，功能完全覆盖synchronized，且支持更多特性。

```java
public void run() {
        while (true) {
            lock.lock();
            try {
                if (ticket <= 0) {
                    break;
                } else {
                    try {
                        Thread.sleep(500);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    System.out.println(Thread.currentThread().getName() + "卖" + ticket--);
                }
            } catch (Exception e) {
                throw new RuntimeException(e);
            } finally {
                lock.unlock();
            }
        }
    }
```

为什么lock.unlock()方法必须写在finally语句块内，假设unlock不在finally语句块内，那么当if条件走到break时直接跳出循环导致unlock不执行，那么拿到锁的线程带着锁出去没有释放锁，其他线程还在等待锁释放，这会导致程序一直执行不会结束。

**核心实现类 2：ReentrantReadWriteLock（读写锁）**
针对 “读多写少” 的场景优化：

 - 读锁（共享锁）：多个线程可同时获取读锁（读操作不互斥）；
 - 写锁（独占锁）：只有一个线程能获取写锁，且写锁持有期间，读锁也无法获取（写操作与读 / 写操作都互斥）。

```java
public class MyThread {

    private static final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();

    private static final ReentrantReadWriteLock.ReadLock readLock = rwLock.readLock();

    private static final ReentrantReadWriteLock.WriteLock writeLock = rwLock.writeLock();

    public void readLock() {
        readLock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + "进行读取操作");
            Thread.sleep(1000);
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            readLock.unlock();
        }
    }

    public void writeLock() {
        writeLock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + "进行写入操作");
            Thread.sleep(1000);
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            writeLock.unlock();
        }
    }
}
```

```java
public void synchronizedTest() {

        for (int i = 0; i < 100; i++) {
            Thread t1 = new Thread(() -> {
                new MyThread().readLock();
            });
            t1.setName("窗口one");
            t1.start();
        }

        for (int i = 0; i < 5; i++) {
            Thread t2 = new Thread(() -> {
                new MyThread().writeLock();
            });
            t2.setName("窗口two");
            t2.start();
        }

    }
```

当写线程没有拿到锁时，很多个读线程会同时拿到读锁一起执行读取操作，但当一个写线程拿到写锁时所有读线程停止拿锁等写线程完毕后再抢锁

### △ 死锁

两个或多个线程互相持有对方需要的锁，且都不释放，导致所有线程永久阻塞。

当两个线程进行时，线程1拿到A锁，线程2同时拿到B锁，当线程1准备拿B锁时，线程2准备拿A锁还没有释放B锁，所以线程1拿不到B锁，线程B拿不到A锁，导致程序一直卡在这，形成死锁。

```java
public class DeadLockDemo {
    // 两把锁
    private static final Object lockA = new Object();
    private static final Object lockB = new Object();

    public static void main(String[] args) {
        // 线程1：先拿lockA，再拿lockB
        new Thread(() -> {
            synchronized (lockA) {
                System.out.println("线程1获取了lockA，等待lockB");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (lockB) {
                    System.out.println("线程1获取了lockB，执行任务");
                }
            }
        }, "线程1").start();

        // 线程2：先拿lockB，再拿lockA（与线程1锁顺序相反）
        new Thread(() -> {
            synchronized (lockB) {
                System.out.println("线程2获取了lockB，等待lockA");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (lockA) {
                    System.out.println("线程2获取了lockA，执行任务");
                }
            }
        }, "线程2").start();
    }
}
```

**如何避免死锁：**

 - 固定锁的获取顺序（比如都先拿 lockA，再拿 lockB）；
 - 使用 tryLock () 超时获取锁（避免永久等待）；
 - 减少锁的持有时间（尽快释放锁）；
 - 使用工具检测死锁（比如 JConsole、jstack 命令）。

### △ 乐观锁与悲观锁

**悲观锁：**
悲观锁就像：你是一个极度谨慎的人，做什么事都「默认一定会有人跟你抢」。

比如你在卫生间🚻，进去第一件事就是反锁门，不管外面有没有人、有没有人要进来，先把门锁上，你在里面办事的期间，任何人都进不来；等你办完事儿，再开门解锁，下一个人才能进来。

**👉 核心心态：凡事往最坏的想，默认必有争抢，先上锁，再办事，绝对安全。**
synchronized锁就是典型的悲观锁

```java
public class MyThread implements Runnable {
    private static int ticket = 100; //共享票数（抢的资源）
    private static final Object LOCK = new Object(); //一把锁

    @Override
    public void run() {
        while (true) {
            // 悲观锁核心：操作资源前，先上锁！
            synchronized (LOCK) { 
                if (ticket <= 0) break;
                System.out.println(Thread.currentThread().getName() + "卖" + ticket--);
            }
            // 解锁：代码块执行完，自动释放锁，下一个线程才能进来
        }
    }
}
```

✅ 效果：3 个窗口线程，谁先拿到锁谁卖票，其他窗口排队，绝对不会出现负数、不会重复卖票，百分百安全！

**乐观锁：**
乐观锁就像：你是一个大大咧咧的人，做什么事都「默认没人跟你抢」。

比如你去复印店复印文件📄，店里有个公用的打印机，你直接过去就开始复印，全程不上锁，心里想着「应该没人跟我抢这台打印机」；
万一真的有人也来用打印机（小概率事件），你俩撞车了，你也不生气，就说「那我重新来一次」，退回去、等对方用完，你再重新复印就行。

**👉 核心心态：凡事往最好的想，默认不会有争抢，先办事，不上锁；万一真的被人抢了、资源被改了，那就「重试一次」。**

Java 中乐观锁的核心思想：

 - 对共享资源（比如你的ticket票数）持「乐观态度」，认为多线程并发访问时，大概率不会发生争抢，大概率不会出问题。
 - 所以操作共享资源时，全程不上锁，直接去修改资源；
 - 但是！修改之前会做一个「核对校验」：看看这个资源「我拿到的时候的值」和「现在要修改的值」是不是一样？
   ✔️ 如果一样：说明没人动过这个资源，修改成功！
   ❌ 如果不一样：说明被别的线程改过了，我这次修改作废，重新拿最新的值，再试一次（重试）。

**CAS机制：**
CAS = Compare And Swap（比较并交换）

我想把票数 ticket 从 100 改成 99 → 先「比较」现在的ticket是不是还是 100？如果是，就「交换」成 99；如果不是，说明被别人改了，重来！

这个「比较 + 交换」是 CPU 层面的原子操作（一次性完成，不会被线程打断），这也是乐观锁能保证线程安全的核心！

 - AtomicInteger：乐观锁版的 Integer，对应你的int ticket
 - AtomicLong：乐观锁版的 Long
 - AtomicBoolean：乐观锁版的 Boolean

```java
public class MyThread implements Runnable {

    private static final AtomicInteger lock = new AtomicInteger(100);

    @Override
    public void run() {
        while (true) {
            int ticket = lock.get();
            if (ticket <= 0) {
                break;
            }

            // 假设现在的票要从100改成99 他会记录当前线程的票数100 则会判断当前的ticket是不是100 
            // 如果是 则会更改 如果不是 说明被其他线程改了
            boolean flag = lock.compareAndSet(ticket, ticket - 1);

            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }

            if (flag) {
                System.out.println(Thread.currentThread().getName() + "@" + ticket);
            }
        }
    }
}
```

**乐观锁与悲观锁总结：**
悲观锁：先锁后做，防患于未然，默认必有争抢，上锁保证绝对安全，适合竞争激烈的场景，代表是synchronized；

乐观锁：先做后核，赌大概率无事，默认没有争抢，不上锁提高效率，万一出事就重试，适合竞争少的场景，代表是Atomic原子类；

锁的本质，就是解决「多线程抢共享资源」的问题，悲观锁和乐观锁只是两种不同的解决思路。

### △ 线程唤醒与等待机制

核心定位：等待唤醒机制 = 为「生产者消费者模型」量身打造的多线程协作方案

什么是【生产者 - 消费者模型】？

**✅ 核心角色（3 个，缺一不可）**

 - 生产者：负责「生产数据 / 资源」的线程 → 比如：包子铺做包子的师傅
 - 消费者：负责「消费数据 / 资源」的线程 → 比如：来买包子的顾客
 - 共享缓冲区 / 仓库：存放生产好的资源的地方，是生产者和消费者的唯一交互媒介 → 比如：包子铺的蒸笼（容量有限，比如最多放 5 个包子）

**✅ 核心需求（必须遵守的 2 个规矩）**
这也是为什么单纯加锁解决不了问题的原因，两个硬性规矩：

 - ✔ 规矩 1：蒸笼满了，师傅就不能再做包子了（仓库满 → 生产者停止生产，等待）；
 - ✔ 规矩 2：蒸笼空了，顾客就不能买包子了（仓库空 → 消费者停止消费，等待）；
 - ✔ 额外规矩：师傅做好 1 个包子，要喊一声「有包子了」；顾客买走 1 个包子，要喊一声「有空位了」。

**✅ 没有「等待唤醒」会怎么样？**

 - 如果只给蒸笼（共享资源）加锁，没有等待唤醒机制，线程会出现两种极端情况，全是问题：
 - 生产者瞎忙活：蒸笼满了还在不停尝试生产，线程一直抢锁、判断、释放锁，白白占用 CPU 资源，这叫「忙等」；
 - 消费者瞎忙活：蒸笼空了还在不停尝试消费，也是一样的「忙等」，纯纯浪费性能；

**3 个核心方法：**
**wait()、notify()、notifyAll() 必须在 synchronized 同步代码块 / 同步方法中调用**
✅ 原因：这三个方法，必须依附于「锁对象」 才能使用。

 - 你用synchronized(锁对象){}锁住了共享资源，那你就必须用这个「锁对象」 去调用这三个方法；
 - 如果不在同步代码块里调用，直接抛异常 IllegalMonitorStateException（非法监视器状态异常），大白话：你没拿到锁，没资格喊等待 / 唤醒！

**wait()、notify()、notifyAll() 必须是「同一个锁对象」调用**
✅ 原因：生产者和消费者，抢的是同一个共享资源的锁，只有用同一个锁对象喊话，对方才能听见。

 - 比如：包子铺的蒸笼是锁对象，师傅（生产者）用蒸笼喊「我等了」，顾客（消费者）必须用同一个蒸笼喊「你醒醒」，如果各喊各的，永远唤醒不了对方。

**wait方法技术底层逻辑**

 - 调用wait()的线程，会立刻释放持有的「当前锁对象」（这点和Thread.sleep()天壤之别！）；
 - 这个线程会从「运行状态」变成「等待状态」，进入这个锁对象的「等待队列」里排队；
 - 线程会一直卡在wait()这行代码不动，直到有其他线程用同一个锁对象喊它（notify()/notifyAll()），它才会被唤醒。


**关键对比：wait () 和 sleep () 最核心区别**

 - wait()：释放锁 + 线程等待，必须在同步代码块里调用；
 - sleep()：不释放锁 + 线程休眠，哪里都能调用；
 - 例子：师傅如果是 sleep (1000)，就是抱着蒸笼睡 1 秒，期间顾客根本碰不到蒸笼；如果是 wait ()，就是把蒸笼让出来，顾客可以直接用。
 - 单个唤醒：锁对象.notify() → 我干完活了，喊一个等着的人过来干活

```java
public class WaitAndNotifyThread {

    public static void makeFood() {
        //一直做食物
        while (true) {
            synchronized (Food.lock) {
                //判断食物到达最大值 如果食物满了 则等待wait 之所以用循环因为假设食物做好之后
                //这把锁的厨师线程被唤醒 发现食物还是满的 则继续等待
                //使用循环判断锁 放置假唤醒 放置错误数据 如果是if则会出现食物数据异常 自己去试
                while (Food.food.equals(Food.maxFood)) {
                    try {
                        System.out.println("食物满了 厨师等待...");
                        Food.lock.wait(); //释放锁
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                }
                //如果食物没满 开始做食物 并提醒吃货们来吃
                Food.food++;
                System.out.println(Thread.currentThread().getName() + "做好了1个食物 目前食物有" + Food.food);
                //唤醒持有这把锁的所有线程 唤醒与等待必须在线程绑定的锁上实现 不然就是唤醒其他所有的线程 非常可怕
                Food.lock.notify();

                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        }
    }

    public static void eatFood() {
        while (true) {
            synchronized (Food.lock) {
                //检查是否有食物 没有食物则等待wait
                while (Food.food.equals(Food.minFood)) {
                    try {
                        System.out.println("目前还没有食物 吃货等待...");
                        Food.lock.wait();
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                }
                //有食物 开吃
                Food.food--;
                System.out.println(Thread.currentThread().getName() + "吃货吃了食物 还剩" + Food.food);
                //唤醒所有线程 开始做饭
                Food.lock.notify();

                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        }
    }
}
```

**使用Lock锁实现阻塞队列：**
开始业务时一般有两个及以上的线程
一半用来put放任务的线程
一半用来take取任务的线程

可以模拟两条生产线
put生产线有任务时会呼唤take生产线
反之则亦然

当put生产线任务满了 会自动睡眠 释放锁 此时take生产线就可以为所欲为了
当take生产线没有任务时 会自动睡眠 释放锁 此时put就可以拿到锁放置任务

```java
/**
     * 阻塞队列的锁 防止任务入队列被挤爆发生数据错乱
     * isEmpty --- take队列任务未满时 阻塞的条件
     * isFull --- put队列满时 阻塞的条件
     */
    private static final ReentrantLock lock = new ReentrantLock();

    private static final Condition isEmpty = lock.newCondition();

    private static final Condition isFull = lock.newCondition();


/**
     * @param runnable 新增任务 需要放入队列
     */
    public void put(Runnable runnable) throws InterruptedException {
        lock.lock(); //获取当前的锁
        try {
            while (size == capacity){ //循环判断队列是否满任务 防止假唤醒
                System.out.println("Queue is full waiting...");
                isFull.await();
            }
            tailQueue[tail] = runnable; //开始向队列中加入任务
            tail = (tail + 1) % capacity; //尾指针后移 如果到尾部则循环回头部
            size++; //队列任务数增加
            isEmpty.signal(); //唤醒持队列接取任务锁的所有线程 让他们抢着接活
        } finally {
            lock.unlock(); //程序执行完释放锁
        }
    }


/**
     * 接取任务
     * @return 有空闲线程[正式员工]可以接这个活
     */
    public Runnable take() throws InterruptedException {
        lock.lock();
        try {
            while (size == 0) { //循环判断当前是否没有任务 没有则等待任务
                System.out.println("Queue is empty waiting...");
                isEmpty.await();
            }
            Runnable runnable = tailQueue[head]; //如果有任务则从队列头中拿取任务
            head = (head + 1) % capacity; //进行头指针迭代
            size--; //总任务数减少
            isFull.signal(); //唤醒所有持有新增任务锁的线程开始增任务
            return runnable; //返回这个活给线程[员工]哥干活
        } finally {
            lock.unlock();
        }
    }
```

### △ 阻塞队列实现等待唤醒机制

**传统wait()和notify()缺点：**

 - 必须手动加 synchronized 锁，锁对象还得保证是同一个，写错就报错；
 - 必须手动写 while 循环判断仓库满 / 空，用 if 就会出现「假唤醒」，数据必错；
 - 必须手动调用 wait() 等待、notifyAll() 唤醒，忘写就会线程卡死；
 - 代码臃肿：核心的「生产 / 消费」逻辑就 1 行，结果被锁、判断、等待唤醒的代码包围了一大圈。

**阻塞队列的【核心优势】：**
阻塞队列的本质：一个自带「等待唤醒机制」的线程安全的队列。
你可以把它理解成：一个有智商、懂规矩的智能蒸笼。

这个「智能蒸笼」自己就懂 2 个铁规矩，不用任何人提醒、不用手动写任何代码：

 - ✔ 规矩 1：蒸笼（队列）满了 → 师傅（生产者）想放包子，自动停下等待，直到有顾客买走包子、队列有空位，自动唤醒师傅继续生产；
 - ✔ 规矩 2：蒸笼（队列）空了 → 顾客（消费者）想买包子，自动停下等待，直到有师傅做好包子、队列有货，自动唤醒顾客继续消费。

**核心结论：**

 - 阻塞队列的底层源码里，依然是用了 Lock锁 + Condition条件 + await()/signal()（等价于原生的synchronized+wait/notify）实现的等待唤醒，只是 JDK 帮我们把这些细节全部封装在队列内部了。
 - 我们作为开发者，只需要调用队列的「放元素、取元素」方法，剩下的等待、唤醒、线程安全，全交给队列自己处理！

**阻塞队列的 2 个「核心阻塞方法」**

**✔ 生产者用：put(E e) 方法 → 往队列里放元素（做包子、放进蒸笼）**

 - 功能：把一个元素放进阻塞队列；
 - 阻塞规则：如果队列已满，调用这个方法的线程会一直阻塞，直到队列有空闲位置，线程被自动唤醒，元素成功放入；
 - 线程安全：自带锁，多个生产者同时放，不会出现数据错乱。

**✔ 消费者用：take() 方法 → 从队列里取元素（买包子、拿出蒸笼）**

 - 功能：从队列的头部取出并删除一个元素；
 - 阻塞规则：如果队列已空，调用这个方法的线程会一直阻塞，直到队列里有新元素，线程被自动唤醒，成功取出元素；
 - 线程安全：自带锁，多个消费者同时取，不会出现数据错乱。

✨ 补充：这两个方法就是「终极懒人版」的等待唤醒，你调用这两个方法，就等于 JDK 帮你执行了「判断 + 加锁 + wait + 唤醒 + 解锁」的全套逻辑！

**put方法源码**

```java
public void put(E e) throws InterruptedException {
        Objects.requireNonNull(e);
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            while (count == items.length)
                notFull.await();
            enqueue(e);
        } finally {
            lock.unlock();
        }
    }
```

**take方法源码**

```java
public E take() throws InterruptedException {
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            while (count == 0)
                notEmpty.await();
            return dequeue();
        } finally {
            lock.unlock();
        }
    }
```

**测试案例**

```java
/**
 * 通俗版 阻塞队列实现生产者消费者（替代wait/notify，实战首选）
 * 核心：BlockingQueue的put()和take()方法 自动实现等待唤醒，无需手动加锁/写wait/notify
 * 包子师傅=生产者，顾客=消费者，智能蒸笼=ArrayBlockingQueue（容量3）
 */
public class BlockingQueueProducerConsumer {
    // 1. 定义阻塞队列作为【智能蒸笼】，固定容量3个包子，线程安全+自带等待唤醒
    private static final BlockingQueue<String> SMART_STEAMER = new ArrayBlockingQueue<>(3);

    public static void main(String[] args) {
        // 2. 创建2个生产者线程：包子师傅
        new Thread(() -> produceBaoZi(), "包子师傅1号").start();
        new Thread(() -> produceBaoZi(), "包子师傅2号").start();

        // 3. 创建3个消费者线程：顾客
        new Thread(() -> consumeBaoZi(), "顾客1号").start();
        new Thread(() -> consumeBaoZi(), "顾客2号").start();
        new Thread(() -> consumeBaoZi(), "顾客3号").start();
    }

    // 生产者方法：做包子 → 往阻塞队列放包子，用put()方法
    private static void produceBaoZi() {
        while (true) { // 循环做包子
            try {
                String baoZi = "猪肉大葱包";
                // 核心：调用put()方法放包子，队列满了会自动阻塞，有空位自动唤醒
                SMART_STEAMER.put(baoZi);
                System.out.println(Thread.currentThread().getName() + "：做好1个包子，智能蒸笼剩余【" + SMART_STEAMER.size() + "】个包子");
                Thread.sleep(500); // 模拟做包子耗时，效果更明显
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    // 消费者方法：买包子 → 从阻塞队列取包子，用take()方法
    private static void consumeBaoZi() {
        while (true) { // 循环买包子
            try {
                // 核心：调用take()方法取包子，队列空了会自动阻塞，有包子自动唤醒
                String baoZi = SMART_STEAMER.take();
                System.out.println(Thread.currentThread().getName() + "：买到1个【"+baoZi+"】，智能蒸笼剩余【" + SMART_STEAMER.size() + "】个包子");
                Thread.sleep(800); // 模拟吃包子耗时，效果更明显
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

### △ 线程池

先说说为什么要有线程池？

假设你是老板，要完成 1000 个干活任务

**方式 1：**
手动创建线程 = 招「临时工」干活

每来 1 个任务，就临时雇 1 个临时工，干完活立刻解雇这个临时工；下一个任务再来，再雇新的临时工。
这种方式的 3 个致命问题：

 - 开销极大，效率极低：雇人（创建线程）、解雇人（销毁线程）都是要花「成本」的（CPU / 内存开销），1000 个任务就要创建销毁 1000 个线程，大部分时间都花在「雇人解雇」上，真正干活的时间很少；
 - 资源耗尽，程序崩溃：如果任务特别多（比如 1 万个），就会瞬间创建 1 万个线程，CPU 要疯狂切换线程、内存被占满，直接导致程序卡死 / 崩溃（内存溢出 OOM）；
 - 无人管理，乱糟糟：所有线程都是零散的，没法统一控制、没法知道任务进度、没法限制干活人数，出了问题都不知道找谁。

**方式 2：**
用线程池 = 建「正规工厂」干活

工厂提前招好一批固定的工人，工人一直待在厂里待命；来了任务，直接分配给空闲的工人干就行；任务多了干不完，就把任务放进任务仓库（阻塞队列） 排队；工人干完一个活，立刻去仓库领新活干；就算活太多，也只会临时招少量临时工，绝不会乱招人；活少了，临时工干一段时间没活就辞退，保证工厂效率最高。

**线程池的核心价值**

线程池的本质：一个「存放线程的池子」，提前创建好一批线程，复用这些线程执行任务，全程统一管理线程的创建、复用、销毁。

 - **线程复用**：核心线程创建后不会销毁，一个线程能执行无数个任务，彻底避免「创建 / 销毁线程」的巨大开销；
 - **控制数量**：能严格限制线程的最大数量，不会出现线程过多导致的 CPU / 内存耗尽问题，保证程序稳定；
 - **任务排队**：任务过多时，自动把任务放进「阻塞队列」排队，不会丢失任务，完美衔接你学过的阻塞队列知识点；
 - **统一管理**：能轻松监控线程状态、任务进度，还能设置任务超时、拒绝策略，线程不再是零散的「野线程」；
 - **提升效率**：任务来了不用等创建线程，直接用池子里的空闲线程执行，响应速度极快。

**线程池的【核心工作原理】**

线程池的工作流程是 固定的执行顺序，也是线程池的灵魂

前置设定（所有线程池都遵守这个设定）：

 - 工厂的「正式工」= 线程池的【核心线程】：招进来就不会轻易辞退，就算没活干，也在厂里待命；
 - 工厂的「临时工」= 线程池的【非核心线程】：只有活特别多的时候才招，没活干一段时间就会被辞退；
 - 工厂的「任务仓库」= 线程池的【阻塞队列】：活干不完的时候，任务就排队放这里（BlockingQueue）；
 - 工厂的「最大人数」= 线程池的【最大线程数】：正式工 + 临时工的总人数，绝对不能超；

**线程池执行任务的「4 步黄金流程」**

 - **第一步：优先找「正式工」干活**
   任务来了，先看池子里的「核心线程（正式工）」有没有空闲的，有就直接分配任务，马上干活；
   如果正式工都在忙，进入第二步。

 - **第二步：任务进「仓库排队」**
   把任务放进线程池内置的「阻塞队列（任务仓库）」里排队，让正式工干完手上的活后，主动去仓库领新任务继续干；
   如果仓库也堆满了、排不下任务了，进入第三步。

 - **第三步：招「临时工」帮忙干活**
   此时任务太多，正式工忙不过来、仓库也满了，线程池会临时创建新的线程（临时工） 来执行任务；
   临时工的数量有上限：正式工 + 临时工 ≤ 最大线程数，绝对不会无限招人；如果临时工也招满了，进入第四步。

 - **第四步：执行「拒单规则」**
   此时：正式工全忙 + 仓库满 + 临时工全忙，已经没有任何能力处理新任务了 → 线程池会执行拒绝策略（拒单），对新任务做处理（比如抛异常、丢弃任务、让提交任务的线程自己干）。

**✅ 核心总结：核心线程 → 阻塞队列 → 非核心线程 → 拒绝策略**

**线程池的【7 个核心参数】（ThreadPoolExecutor）**

```java
public ThreadPoolExecutor(
    int corePoolSize,        // 参数1：核心线程数 → 工厂的「正式工人数」
    int maximumPoolSize,     // 参数2：最大线程数 → 工厂「正式工+临时工」的总人数上限
    long keepAliveTime,      // 参数3：空闲超时时间 → 临时工没事干，多久后被辞退
    TimeUnit unit,           // 参数4：时间单位 → 配合参数3，比如：秒、毫秒
    BlockingQueue<Runnable> workQueue, // 参数5：阻塞队列 → 工厂的「任务仓库」
    ThreadFactory threadFactory,       // 参数6：线程工厂 → 招人规则（给线程起名字、设置优先级）
    RejectedExecutionHandler handler    // 参数7：拒绝策略 → 任务爆满时的「拒单规则」
)
```

- **✔ 1. corePoolSize 核心线程数（正式工人数）**
  线程池常驻的线程数量，线程池创建后，会初始化这些线程，就算没任务，这些线程也不会销毁，一直待命；
  比如设置corePoolSize=5，就是工厂固定有 5 个正式工，随时干活。

 - **✔ 2. maximumPoolSize 最大线程数（总人数上限）**
   线程池能创建的最大线程总数，包含「核心线程 + 非核心线程」；
   规则：最大线程数 ≥ 核心线程数；比如corePoolSize=5，maximumPoolSize=10，说明最多能招 5 个临时工。

 - **✔ 3. keepAliveTime + TimeUnit unit 空闲超时时间 + 单位**
   专门针对「非核心线程（临时工）」的规则：临时工干完活后，空闲多久就被辞退；
   比如keepAliveTime=3，unit=TimeUnit.SECONDS → 临时工空闲 3 秒，就被解雇，释放资源；
   补充：可以通过方法设置「核心线程也能超时销毁」，默认核心线程永不销毁。

 - **✔ 4. workQueue 阻塞队列（任务仓库）**
   线程池的任务排队容器，就是你之前学的BlockingQueue接口的实现类；
   常用实现：ArrayBlockingQueue（有界队列，推荐）、LinkedBlockingQueue（链表队列）；
   ✅ 核心原则：开发中必须用「有界队列」（指定容量），绝对不能用无界队列！否则任务无限排队，内存直接炸了。

 - **✔ 5. handler 拒绝策略（拒单规则）**
   任务爆满时的处理规则（核心线程忙 + 队列满 + 非核心线程忙），JDK 内置了 4 种默认策略，都是ThreadPoolExecutor的静态内部类，通俗好懂：
   `AbortPolicy（默认）`：直接抛异常「拒绝任务」，告诉调用者：任务满了，处理不了；开发中最常用，能及时发现问题；
   `CallerRunsPolicy`：让「提交任务的线程」自己执行这个任务（比如主线程提交任务，就主线程自己干），不会丢任务，也不抛异常；
   `DiscardPolicy`：默默丢弃最新的任务，不抛异常、不提示，不推荐，丢了任务都不知道；
   `DiscardOldestPolicy`：丢弃队列里最老的任务，把位置让给新任务，也不抛异常。

 - **✔ 6. threadFactory 线程工厂 & 7. 其他**
   线程工厂：就是「创建线程的规则」，比如给线程起个有意义的名字（方便调试）、设置线程优先级等；
   这两个参数属于「锦上添花」。

**线程池的创建：**

```java
public void threadPoolTest() {
        ThreadPoolExecutor tpe = new ThreadPoolExecutor(
                5,                  // 核心线程数（正式工）：5个
                10,                 // 最大线程数（总人数）：5正式+5临时
                60,                  // 临时工空闲3秒就辞退
                TimeUnit.SECONDS,   // 时间单位：秒
                new ArrayBlockingQueue<>(10), // 阻塞队列：任务仓库，最多放10个任务（有界，核心！）
                Executors.defaultThreadFactory(), // 默认线程工厂
                new ThreadPoolExecutor.AbortPolicy() // 拒绝策略：任务爆满抛异常（默认）静态内部类
        );

        //提交20个任务执行（5正式+5临时+10队列=20，刚好容纳，再多就抛异常）
        for (int i = 0; i < 20; i++) {
            int finalI = i;
            tpe.execute(() -> {
                System.out.println(Thread.currentThread().getName() + "----" + finalI);
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            });
        }
    }
```

### △ 线程池设置多大合适

Java中使用Runtime.getRuntime().availableProcessors()获取当前计算机能够使用的cpu数

```java
// 获取CPU核心数，返回int类型（比如8核返回8）
int coreNum = Runtime.getRuntime().availableProcessors();
```

**线程池的核心线程数设置，唯一的核心依据：**
你的业务任务是「CPU 密集型」还是「IO 密集型」，这两种任务的线程运行状态天差地别，配置原则完全相反！
线程数设置的终极目标：让 CPU 的利用率达到最高，不浪费、不超载

**CPU 密集型任务：线程「霸占 CPU 不松手」**
任务的执行逻辑，99% 的时间都在占用 CPU 做计算，没有任何停顿 / 等待，典型场景：

 - 数据计算、排序（冒泡 / 快排）、遍历海量集合；
 - 加密 / 解密、压缩 / 解压缩、数学运算；
 - 纯内存数据处理，无任何磁盘 / 网络交互。

```java
核心线程数 = CPU核心数 + 1
最大线程数 = 核心线程数 （和核心线程数保持一致即可）

为什么要 +1 ？
CPU 密集型任务的线程，会霸占 CPU 不松手，理论上「CPU 核心数 = 线程数」刚好占满所有核心，效率最高。
+1 的目的：做「备用线程」，防止某个线程因为偶尔的、极短暂的阻塞（比如一次内存分配失败、一次 GC 停顿）导致 CPU 核心空闲，这个备用线程可以立刻补上，让 CPU 利用率始终保持 100%，不浪费一丝性能。
```

 **IO 密集型任务：线程「大部分时间摸鱼，偶尔干活」**
 任务的执行逻辑，90% 的时间都在「等待」，只有 10% 的时间在占用 CPU 干活，典型场景：

 - 数据库操作：Mybatis/JDBC 查询、插入、更新数据；
 - 缓存操作：Redis 读写、Memcached 交互；
 - 文件 / 网络 IO：读写本地文件、调用第三方接口、微服务之间的远程调用、HTTP 请求；
 - 消息队列：生产 / 消费 MQ 消息；

```java
核心线程数 = CPU核心数 × 2
最大线程数 = 核心线程数 （无需非核心线程）
```

### △ Volatile关键字

volatile 是 Java 中轻量级的并发关键字
**作用：**

 - ✅ ① 保证变量的 可见性
 - ✅ ② 禁止指令的 重排序
 - 但是不能保证原子性！

**核心功能：**

 - 主内存 ：相当于你们班级的「黑板」，所有同学（线程）都能看到，黑板上写的内容是「唯一的、最新的、真实的」。

 - 线程的工作内存（缓存） ：相当于每个同学自己的「笔记本」，同学看黑板上的内容后，会抄到自己的笔记本上，之后做题就只看自己的笔记本，不会每次都抬头看黑板。

 - 线程操作变量的本质 ：Java 中所有变量都存在「主内存」，每个线程执行时，不会直接操作主内存的变量，而是先把变量「复制一份」到自己的「工作内存（缓存）」里，之后对变量的读、改操作，全是在自己的缓存里执行。

**没有 volatile 时，会出现 2 个致命问题**

 - ❌ 问题 1：【缓存不一致 → 可见性缺失】
   比如黑板上写了数字 0，同学 A、B 都抄到笔记本上。
   同学 A 把自己笔记本的数字改成 1，但是没有把修改后的数字写回黑板，或者写回去了但同学 B「没抬头看黑板」，同学 B 的笔记本上永远是 0。
   → 这就是线程 A 的修改，对线程 B「不可见」。
 - ❌ 问题 2：【CPU 乱序执行 → 有序性缺失】
   CPU 为了提升执行效率，会对代码的「执行指令」做 「重排序」：比如你写的代码是步骤1→步骤2→步骤3，CPU 可能实际执行步骤2→步骤1→步骤3，只要最终结果不变就行。

## ○ [\[Git\]手写Java线程池](https://github.com/Lotdzzz/javaSE-project/tree/JavaThreadPool)