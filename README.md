# JavaThreadPool

## 1：PoolBlockingQueue

线程池的阻塞队列，任务缓冲区

**核心定位**：线程安全的**有界阻塞队列**，是线程池的「任务缓冲区」，所有提交的任务最终都会落到这里（或被线程直接执行）。

**核心能力**：存任务 (`put`)、取任务 (`take`)、超时取任务 (`poll`)、判断空 / 满；

**阻塞特性**：队列满则放任务的线程阻塞，队列空则取任务的线程阻塞。

## 2：ThreadPoolExecute

线程池总调度中心

**核心定位**：线程池的核心类，统筹一切：初始化核心线程、接收任务、调度任务执行、创建 / 销毁临时工线程、关闭线程池、执行拒绝策略。

**核心成员**：核心线程数 / 最大线程数 / 空闲超时时间 / 时间单位 / 阻塞队列 / 拒绝策略；存储核心线程的集合、存储临时工线程的集合；线程池关闭标记`volatile boolean isShutdown`。

**核心方法**：`execute(Runnable task)` 提交任务（核心方法）、`startFactoryPoolByFormal()`初始化核心线程、`startFactoryPoolByTemporary()`创建临时工线程、`shutdown()`关闭线程池。

**内部核心类**：`FormalWorker`（核心线程的线程体）、`TemporaryWorker`（临时工线程的线程体）—— 本质就是封装了`run()`方法的线程，负责循环取任务、执行任务。

## 3：TimeTypeEnum

辅助文件：类似TimeUnit

**核心作用**：统一时间单位转换，给临时工线程的`poll()`方法提供「纳秒」的超时时间转换，避免硬编码。

## 4：流程

### 1：初始化阶段

**new MyThreadPool (...) → 线程池启动，核心线程就位待命（无任务，准备干活）**

```java
ThreadPoolExecute threadPoolExecute = new ThreadPoolExecute(
            5,                  // 核心线程数（正式工）：n个
            10,                 // 最大线程数（总人数）：n正式+m临时
            20,                  // 临时工空闲s单位就辞退
            TimeTypeEnum.SECOND,   // 时间单位：单位
            new PoolBlockingQueue<>(10) //自定义阻塞队列
    );
```

- 构造方法接收所有参数，给成员变量赋值（核心线程数、最大线程数、队列等）；

- 调用 `startFactoryPoolByFormal()` 初始化核心线程，内层循环 5 次（corePoolSize=5）执行：new FormalWorker(null)；

- `new FormalWorker(null)` 做两件事：① 创建`FormalWorker`核心线程对象（传入`task=null`）；② 调用`worker.start()`启动核心线程；

- **核心线程启动后的关键行为**：核心线程执行自身的`run()`方法 → 因为`task=null`，直接调用 `queue.take()` 去阻塞队列取任务；

- **阻塞队列的联动**：此时队列为空，核心线程执行`take()`时，会获取`takeLock`锁，然后进入`while(size==0)`循环，调用`takeLock.await()` **永久阻塞挂起**；

- 最终状态：2 个核心线程全部卡在`queue.take()`的`takeLock.await()`处，处于**WAITING 等待状态**，不占用 CPU、时刻待命，这就是「正式工提前就位，等任务上门」。

关键细节：核心线程是**线程池初始化就启动，永久存活**，除非线程池关闭，不会自己销毁，这是线程池「线程复用」的核心！

### 2：任务提交阶段

主线程调用 threadPool.execute (任务) 

**`execute()`方法的逻辑:**

- ✅ 优先级 1：核心线程数未满 → 直接走核心线程执行任务

- ✅ 优先级 2：核心线程已满 → 把任务放入阻塞队列缓存

- ✅ 优先级 3：队列已满 → 创建临时工线程执行任务

- ✅ 优先级 4：临时工线程数达上限 → 执行拒绝策略

**任务入列的速度 恒大于 取任务速度：[线程调度问题]**

### 3：核心线程任务交互

- **有任务时**：取到任务 → 执行`task.run()` → 任务执行完毕 → `task=null` → 循环继续 → 调用`queue.take()` → 取新任务；

- **无任务时**：调用`queue.take()` → 队列空 → 核心线程阻塞在`takeLock.await()` → 不占用 CPU，不执行任何代码，时刻待命；

- **有新任务入队时**：队列的`put()`方法唤醒阻塞的核心线程 → 线程从`await()`恢复 → 取到新任务 → 执行任务；

- **线程池关闭时**：主线程调用`shutdownNow()` → 核心线程被中断 → 抛出`InterruptedException` → 循环退出 → 线程优雅销毁；

- **核心优势**：**线程复用** —— 一个核心线程可以执行**无数个任务**，避免了「创建线程→执行任务→销毁线程」的巨大性能损耗

### 4：临时线程任务交互

- **有任务时**：和核心线程一样，取任务→执行→释放引用，循环执行；

- **无任务时**：调用`queue.poll(3秒)` → 队列空 → 临时工线程阻塞在`takeLock.awaitNanos()` → 等待 3 秒；

- **3 秒内有任务**：被唤醒，取到任务，执行任务，继续循环；

- **3 秒超时无任务**：`poll()`返回 null → 从`temporaryThreads`集合中移除自己 → `return`退出循环 → 线程自动销毁；

- **线程池关闭时**：被中断，抛出异常，退出循环，销毁；

- **核心优势**：**弹性扩容 + 自动回收** —— 任务多的时候自动创建，任务少的时候自动销毁，不会占用多余的系统资源，解决「任务量波动」的场景

线程调度问题：
主线程执行第 1 次execute() → 队列空 → put(任务1) → 队列size=1 → 执行takeLock.signal() → 立刻唤醒线程池的正式工线程 A；
✅ 【关键】线程 A 被唤醒后，需要 CPU 调度才能开始执行，这个调度耗时「几微秒」；
但主线程是同步执行的，在这「几微秒」的调度间隙，主线程已经执行完了剩下的 9 次 for 循环，瞬间提交了任务 2~ 任务 10；
任务 2 被正式工线程 B 接手，任务 3~ 任务 10 被快速放入队列，瞬间把队列填满；
此时，CPU 才完成线程 A 和线程 B 的调度，两个线程开始执行take() → 取出任务 1、任务 2 → 打印Take xxx → 执行任务打印在干活中...；
队列满后，主线程提交的后续任务触发queueIsFull() → 打印Queue is full waiting...；
线程执行完任务后，队列有空位 → 主线程的阻塞任务继续put，循环往复。
✅ 核心关键点：不是队列「加满才唤醒」，是「唤醒了线程，但线程没来得及执行，队列就被塞满了」
队列在put第一个任务时，已经执行了takeLock.signal()唤醒线程，这个逻辑是立刻执行的，没有任何延迟！只是线程的调度速度跟不上主线程的提交速度，这是CPU 的特性
