# 手写Java线程池先大体整一下思路
思路：[创造开店成本] 创建阻塞队列 创建线程核心数等等 </br>
1 [开家饭店] 先创建一个池子外壳 壳包括线程核心数 阻塞队列等等 </br>
2 [招募正式员工] 初始化线程池时生成常驻线程 在阻塞队列拿任务 出生时应该是阻塞wait状态 因为没有任务 </br>
3 [正式员工开始干活] 调用execute方法新增任务 </br>
4 [招临时工] 假设阻塞队列长度为10但有20个任务 出五个任务给正式工 现在就要招五个临时工 才会不爆仓 </br>

线程调度问题：
主线程执行第 1 次execute() → 队列空 → put(任务1) → 队列size=1 → 执行takeLock.signal() → 立刻唤醒线程池的正式工线程 A；
✅ 【关键】线程 A 被唤醒后，需要 CPU 调度才能开始执行，这个调度耗时「几微秒」；
但主线程是同步执行的，在这「几微秒」的调度间隙，主线程已经执行完了剩下的 9 次 for 循环，瞬间提交了任务 2~ 任务 10；
任务 2 被正式工线程 B 接手，任务 3~ 任务 10 被快速放入队列，瞬间把队列填满；
此时，CPU 才完成线程 A 和线程 B 的调度，两个线程开始执行take() → 取出任务 1、任务 2 → 打印Take xxx → 执行任务打印在干活中...；
队列满后，主线程提交的后续任务触发queueIsFull() → 打印Queue is full waiting...；
线程执行完任务后，队列有空位 → 主线程的阻塞任务继续put，循环往复。
✅ 核心关键点：不是队列「加满才唤醒」，是「唤醒了线程，但线程没来得及执行，队列就被塞满了」
队列在put第一个任务时，已经执行了takeLock.signal()唤醒线程，这个逻辑是立刻执行的，没有任何延迟！只是线程的调度速度跟不上主线程的提交速度，这是CPU 的特性
