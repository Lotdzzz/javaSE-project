# ● JDK JRE JVM

三者关系：JDK > JRE > JVM

## ○ JVM

**（Java Virtual Machine）：Java 虚拟机** 
JVM 就是一个 专门的翻译官 + 运行引擎。
我们写的java代码，不能直接丢给操作系统（Windows/Mac/Linux），它看不懂，而是编译成一种叫「字节码」的通用代码；JVM 的作用就是：把这份通用的 Java 字节码，翻译成你电脑系统能看懂的「母语指令(也就是汇编语言二进制)」，然后指挥电脑执行代码。
**特点：**
「一次编写，到处运行」，全靠 JVM！
		比如你在 Windows 上写的 Java 程序，拿到 Mac/Linux 上不用改一行代码就能运行，原因是：不同的操作系统，都有对应版本的 JVM 翻译官，Java 字节码是通用的，只是换个翻译官而已，核心代码不变。
**JVM运作大体流程：**
		JVM 运行 Java 代码时，会把内存划分为 两大核心类型 的区域，所有代码执行的内存操作都围绕这两块展开，划分原则是「线程归属」，也是整个运作流程的基础：
		 ✅线程共享区（全局唯一，所有线程共用） ：堆（Heap） + 方法区（Method Area，JDK8 叫元空间）
		 ✅ 线程私有区（线程独有，随线程创建而生、线程销毁而灭，互不干扰） ：虚拟机栈 + 程序计数器 + 本地方法栈

### △ 虚拟机栈

**（Java Virtual Machine Stack）[线程私有]**
**核心作用**
是 Java 方法执行的「核心载体」，Java 中每一个方法的调用与执行，都对应虚拟机栈中一个「栈帧」的「入栈 → 执行 → 出栈」，没有虚拟机栈，就没有方法的执行。
**栈帧：**（虚拟机栈的最小单位）包含内容
每个栈帧对应一个方法，里面存着：局部变量表（方法内的局部变量、方法入参）、操作数栈（临时存放运算数据，做加减乘除等计算）、动态链接（指向方法区的当前方法字节码）、方法返回地址。
**特点：**
遵循 先进后出（FILO） 栈结构：调用 A→A 调用 B→B 调用 C，栈帧压入顺序 A→B→C，执行完 C 先弹栈，再弹 B，最后弹 A；
内存释放：方法执行完毕（return / 异常结束），对应栈帧立刻出栈，内存自动释放，无需 GC；
异常：方法递归调用过深（无终止递归）→ 栈溢出 StackOverflowError；虚拟机栈内存配置过小 + 创建栈帧过多 → OOM 内存溢出；
方法内的局部变量，都存在虚拟机栈的栈帧里。

### △ 程序计数器

**（Program Counter Register）[轻量]**
**核心作用**
精准记录 当前线程正在执行的「Java 字节码指令的行号 / 地址」，简单说：给 CPU「指路」，告诉 CPU 下一行要执行哪条字节码指令。
**特点：**
线程切换的核心保障：CPU 切换线程时，程序计数器会保存当前线程的执行位置；线程再次获得执行权时，直接从记录的位置继续执行，不会错乱、不会丢执行进度；
绝对唯一特殊点：JVM 所有内存区域中，唯一一个不会抛出任何内存异常（无 OOM、无 StackOverflowError）的区域；
内存占用：极小，轻量级到几乎可以忽略不计；
补充：如果线程正在执行native本地方法，程序计数器的值会暂时变为空 (undefined)。

### △ 本地方法栈

**（Native Method Stack）**
**核心作用**
作用和虚拟机栈完全一致，唯一区别：虚拟机栈为「Java 编写的普通方法」服务，本地方法栈为「被native关键字修饰的本地方法」服务（底层是 C/C++ 实现，非 Java 代码）。
**特点：**
常见 native 方法：Object.hashCode ()、Thread.start0 ()、System.arraycopy ()，都是 JDK 底层自带的，我们几乎不用自定义；
异常：和虚拟机栈一样，调用 native 方法过深会触发 StackOverflowError，内存不足会触发 OOM；
一句话总结：虚拟机栈管 Java 方法，本地方法栈管 C/C++ 方法，功能同源、各司其职。

### △ 堆

**（Heap）[内存占比最大、GC 核心区域]**
**核心作用**
JVM 中唯一存放「对象实例本体」[Class实例(通过Class类加载的对象模板)]和「数组本体」的区域，Java 代码中只要执行 new 关键字（比如new User()、new String()、new int[10]），创建出来的东西，本体一定在堆里，没有任何例外！
补充：new出来的对象如果包含方法，那只存方法的引用地址，方法实际存在方法区
**特点：**
1：内存占比：JVM 进程中 内存占用最大的区域（默认占 JVM 总内存的 70%+）；

2：引用规则（灵魂考点）：堆里存对象本体，虚拟机栈里永远只存「对象的引用地址」，比如 User user = new User();
new User() → 堆中创建 User 对象本体，初始化属性，分配内存；
User user → 局部变量，存在虚拟机栈的栈帧局部变量表中；
= → 把堆中 User 对象的内存地址，赋值给局部变量 user；

3：存储内容：对象的所有成员变量（非 static 的属性） 都跟着对象本体存在堆里；

4：垃圾回收核心：堆是 JVM 垃圾回收（GC）的「唯一主战场」，没有之一！当一个对象没有任何引用地址指向它时，会被标记为「垃圾对象」，GC 会自动回收这块内存，释放空间；

5：异常：创建的对象过多、对象生命周期过长，GC 来不及回收 → 堆内存溢出 OOM (OutOfMemoryError)，这是开发中最常见的内存异常；

6：线程特性：全局共享，所有线程都能访问堆中的对象，这也是堆中会出现「并发安全问题」的根源。

### △ 方法区

**（Method Area）[JDK8 改名元空间 Metaspace 线程共享]**
**核心作用**
存储 Java 类的 元数据信息（类的模板），是 JVM 加载.class 字节码文件后，存放「类的核心信息」的区域，简单说：类的定义是什么样的，就存在方法区里。
**存储的核心内容**
类的完整结构：类的包名、类名、父类、接口、字段（属性）定义、方法定义；
静态相关：所有 static 修饰的静态变量、静态方法的字节码指令；
常量相关：字符串常量池（JDK7 后移到堆里）、final 修饰的常量；
其他：方法的字节码指令、符号引用、访问权限修饰符（public/private）等。
**特点：**
版本变更：JDK7 及之前叫「方法区」，物理内存在 JVM 堆内存中；JDK8 彻底移除方法区，替换为「元空间（Metaspace）」，物理内存从 JVM 堆内，转移到了 操作系统的本地内存 中；本质作用没变，只是存储位置变了，名字变了。

存储规则：static 静态变量 一定存在方法区（元空间）里，和堆 / 栈无关；、

内存释放：类的元数据只有在「类被卸载」时才会释放，类卸载的条件非常苛刻（几乎很少触发），所以方法区的内存回收效率极低；

异常：加载的类过多（比如动态代理生成大量类、框架加载过多类）→ 方法区 / 元空间内存溢出 OOM；

线程特性：全局共享，所有线程共用同一块方法区内存。

### △ 内存模型图

图来自[https://www.bilibili.com/video/BV1fh411y7R8/?spm_id_from=333.337.search-card.all.click&vd_source=cc7c91e214cab08f67a0c0a813c18647]
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/852ed99a4ed3488ea9cd58cdb1f27b02.png)
图来自百度：
![图By百度](https://i-blog.csdnimg.cn/direct/419ab121d2654595b0498802f5c18fcd.png)
Java程序的开发过程与运行过程（图自来：https://www.bjpowernode.com/tutorial_java_se/57.html）：
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/43450dc647654c38b321e3945286863c.png)
**类加载子系统：**
在磁盘中的class文件将其加载到jvm虚拟机内走一遍jvm内存模型流程
将类的元信息（类结构、方法、字段等）存储到 元空间（方法区） 里，供后续执行使用。
**字节码执行引擎：**
是 JVM 中负责执行字节码的 “动力核心”：把类加载子系统加载好的.class字节码指令，翻译成当前操作系统能识别的机器指令，最终让 CPU 执行。

两种模式：
1：解释执行：逐行翻译字节码指令，执行一行翻译一行（启动快，但执行效率低）；

2：即时编译（JIT）：把频繁执行的 “热点代码”（比如循环、常用方法）一次性编译成机器码缓存起来，后续直接执行缓存的机器码（执行效率高，但首次编译需要时间）。

jvm会将class文件译成二进制汇编语言与操作系统交互

## ○ JRE

**✅ 核心定义**
		JRE 是 Java Runtime Environment 的缩写，中文叫「Java 运行时环境」，它是运行 Java 程序的必备基础环境，专门负责解析、执行已经编译好的 Java 字节码文件（.class 文件），仅提供「运行能力」，没有编译 Java 源代码的功能。
**✅ JRE 的核心组成（2 个核心部分，缺一不可）**
		JRE 是一个完整的运行环境，核心由两部分构成：
Java 虚拟机（JVM）：这是 JRE 的核心核心，是真正执行 Java 字节码的底层引擎，负责字节码的解释 / 编译执行、内存分配与回收（GC 垃圾回收）、线程调度等核心工作；
		Java 核心类库（Java SE API）：Java 提供的基础标准类库（比如 java.lang、java.util、java.io 等包），Java 程序运行时必须依赖这些类库实现基础功能，这部分类库是运行 Java 程序的基础支撑。
补充：JRE 内部还包含一些运行时的支撑文件、系统配置等，是一个开箱即用的完整运行包。

## ○ JDK

**JDK 基础定义**
JDK 全称 Java Development Kit（Java 开发工具包），是 Oracle 官方提供的、面向 Java 程序员的核心开发套件，是进行 Java 程序开发的必备基础环境，所有 Java 开发都基于 JDK 完成。
**JDK 的核心组成**
1：内置JRE环境，自带java运行环境，无需安装jre即可运行java编译后的class文件

2：内置核心开发编译工具：如常用的javac.exe（将.java文件编译为.class的jvm可运行文件）还有java.exe启用jvm虚拟机执行class文件，javadoc.exe文档生成工具等

## 总结

**✅ JDK ⊃ JRE ⊃ JVM**
JVM (Java Virtual Machine)：Java 虚拟机，Java 的「跨平台核心」，负责解析运行.class字节码文件；JVM 不能独立运行，必须依赖 JRE 的类库支持。

JRE (Java Runtime Environment)：Java 运行环境，包含 JVM + 运行 Java 程序所需的核心类库；JRE 只有运行能力，没有开发 / 编译能力，适合只需要运行 Java 程序的普通用户。

JDK：Java 开发工具包，包含完整 JRE + 全套 Java 开发 / 编译 / 调试工具；JDK 是开发专属，有了 JDK，既能写代码、编译代码，也能运行代码。

**JDK 是 Java 开发的必备工具包，包含开发工具 + 运行环境，是 JRE 的超集，而 JRE 又是 JVM 的超集，三者层层包含，共同支撑 Java 的开发与运行。**