# ● 面向对象

**面向过程：**
关注「步骤」，我要做一件事，得拆解成「第一步做什么、第二步做什么、第三步做什么」，所有步骤自己写，从头到尾指挥到底。

**面向对象**
关注「谁来做」，我要做一件事，先找「能做这件事的东西 / 人」，然后直接喊它来做，我不用管它具体怎么完成的。

## ○ 封装

**封装 = 把东西「装起来」，对外只留「能用的门」，内部的东西不让外人乱碰、乱改。**

比如：你的手机 → 手机内部有电池、主板、芯片这些核心零件（内部东西），都被手机外壳「封装」起来了，你看不到也摸不到；手机只给你留了屏幕、按键、充电口这些「能用的门」，你只能通过这些门来用手机，不能直接去抠主板。

 好处：
 ① 安全：不会被乱改内部零件导致坏了；
 ② 方便：你不用懂内部原理，只用会用按键就行。

```java
public class User {
    // 1. 把【属性】私有化：private修饰 → 相当于手机的内部零件，藏起来，外部不能直接改
    private Integer id;       // 用户ID
    private String name;      // 用户名
    private Integer age;      // 年龄
    private String status;    // 状态

    // 2. 对外只留【能用的门】：提供get/set方法 → 相当于手机的按键，外部只能通过这些方法操作属性
    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        // 还能加规则：比如年龄不能是负数，非法数据直接拦截，这就是封装的安全！
        if(age < 0) {
            this.age = 0;
        } else {
            this.age = age;
        }
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }
}
```

## ○ 继承

**继承 = 儿子继承父亲的「特征和本事」，儿子不用重新学，直接能用；儿子还能有自己的「新特征、新本事」，甚至能把父亲的本事改得更好。**

比如：你（儿子）继承了你父亲的「黑头发、大眼睛」这些特征，也继承了「吃饭、走路」这些本事；你不用重新学走路，直接就会；同时你还有自己的新本事（比如编程），还能把父亲的「做饭」本事改得更好吃。

子类能直接用父类的所有属性和方法，不用重新写；
子类能新增自己的属性和方法；
图来自[https://www.bilibili.com/video/BV1fh411y7R8/?spm_id_from=333.337.search-card.all.click&vd_source=cc7c91e214cab08f67a0c0a813c18647]
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/07e3495303cf49dba9d65f192714e6c0.png)
`方法区依次加载main方法以及son到object的class字节码并加载其类内信息——main方法压栈创建局部变量son——堆内开辟son对象内存空间——这个空间存储了son的属性及其父类的属性——属性的赋值是常量的都存在方法区基本数据类型则在堆内——堆内存对象赋值给son变量——son内存存储了其父类的变量及属性值不管是不是private和protected——访问son的变量时如果son也有和父类一样的属性则优先访问son的属性——没有的话就访问在son内存内的其父类的属性值（依次从父亲——爷爷访问）（如果是public或protected可以访问的话）`
**ps：继承后的子对象内存内存父类及父类的父类属性和方法因此可以直接用访问**

```java
// 父类：人类，定义了所有人都有的特征和行为
public class Person {
    private String name;
    private Integer age;
    public void eat() {
        System.out.println(name + "在吃饭");
    }
}
// 子类：学生类，继承人类 → 不用写name、age、eat()，直接能用
public class Student extends Person {
    // 1. 新增自己的属性 → 学生特有的：学号
    private String studentId;
    
    // 2. 新增自己的方法 → 学生特有的：上课
    public void goToClass() {
        System.out.println(getName() + "去上课");
    }
    
    // 3. 重写父类的方法 → 把父亲的"吃饭"改一下，学生吃饭更快
    @Override
    public void eat() {
        System.out.println(getName() + "狼吞虎咽的吃饭");
    }
}
```

**继承的好处：减少代码重复**
比如学生、老师、员工，都是人，都有姓名、年龄、吃饭走路的行为，不用在每个类里都写一遍，只需要写一个父类，子类继承就行，大大减少代码量，后期改起来也方便。

## ○ 多态

**多态 = 「同一个动作 / 指令」，不同的对象做出来，效果完全不一样。**

**[总结一句话：父类型引用指向子类型的对象]**
例如：
指令都是：「叫一声」
狗 听到后 → 汪汪汪的叫；
猫 听到后 → 喵喵喵的叫；
鸡 听到后 → 咯咯咯的叫；
人 听到后 → 喊一声「哎」。

```java
// 父类：动物类，定义一个"叫"的方法
public class Animal {
    public void shout() {
        System.out.println("动物叫了一声");
    }
}

// 子类：狗，重写"叫"的方法
public class Dog extends Animal {
    @Override
    public void shout() {
        System.out.println("汪汪汪");
    }
}

// 子类：猫，重写"叫"的方法
public class Cat extends Animal {
    @Override
    public void shout() {
        System.out.println("喵喵喵");
    }
}

// 测试：同一个指令，不同对象，执行不同结果
public static void main(String[] args) {
    Animal animal1 = new Dog(); // 父类引用 指向 子类对象
    Animal animal2 = new Cat(); // 父类引用 指向 子类对象
    
    animal1.shout(); // 执行狗的叫 → 汪汪汪
    animal2.shout(); // 执行猫的叫 → 喵喵喵
}
```

## ○ this/super关键字

**this**
图来自[https://www.bilibili.com/video/BV1fh411y7R8/?spm_id_from=333.337.search-card.all.click&vd_source=cc7c91e214cab08f67a0c0a813c18647]
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a8146d5179be4c8e9d0b460b5733629e.png)
`this关键在在堆内对象空间内的一块地址空间，这个地址指向的是对象本身的地址`
**super**
`super则是在对象内存内直接跳过子类的成员属性和方法等直接访问超类的`

## ○ 动态绑定机制

**动态绑定：执行子类不存在父类存在的方法时，当这个方法中存在父子都存在的方法就会触发动态绑定机制，外方法sum1执行父类而里面getI执行的是子类的**
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/1d9f2381c3684af388a16f7ac8708de2.png)

## ○ 作用域

**全局变量与局部变量：**

局部变量未赋值不能直接使用而全局变量可以

全局变量默认初始化时会创建默认值

访问变量使用就近原则，全局与局部一样的变量名如果是局部访问则使用局部变量的

**静态域：**
**static = 静态的，被 static 修饰的所有东西（变量、方法、代码块），统称为「静态域」。**

【静态成员变量】→ 存在「方法区」的类模板里
比如：static String className = "一班"，这个值存在「方法区的 User 类模板 也就是加载的class内」里；

核心原因：静态变量属于「类」，不属于对象，类一加载，方法区就会创建这个类的模板，静态变量就跟着加载好了，早于所有对象的创建；

静态变量与方法被所有的对象实例（运行类型）共享

**代码块:**
你之前写的方法里的代码、循环里的代码，其实都是代码块，Java 里给代码块分了类，不同的代码块有「不同的执行时机」—— 不用手动调用，到了特定的时间，代码块会「自动执行」 ，这就是代码块的核心！

`静态代码块 > 构造代码块 > 普通代码块`

**✔️ ① 普通代码块 —— 最普通：方法里的代码块**
定义：写在 方法里、循环里、if 里 的 {} 代码块，就是普通代码块；

执行时机：调用方法的时候，执行到这个代码块，才会运行；

作用：把方法里的代码「分组」，让逻辑更清晰，没别的特殊作用；

```java
public class Student {
    public void test() {
        System.out.println("方法开始");
        // 普通代码块
        {
            int a = 10;
            System.out.println("普通代码块执行：" + a);
        }
        System.out.println("方法结束");
    }
    public static void main(String[] args) {
        new Student().test(); // 调用方法，才会执行代码块
    }
}
```

**✔️ ② 构造代码块 —— 核心：对象出生时「自动执行」，在构造方法前执行**
定义：写在 类里、所有方法外面 的 {} 代码块，没有任何修饰符，就是构造代码块；

执行时机：每次 new 一个对象的时候，都会自动执行，而且执行在「构造方法」之前；

核心作用：给所有对象统一初始化属性，不用在每个构造方法里重复写初始化代码，减少重复代码；

```java
public class Student {
    String name;
    // 构造代码块 ✔️
    {
        name = "李四";
        System.out.println("构造代码块执行了");
    }
    // 构造方法
    public Student() {
        System.out.println("构造方法执行了");
    }
    public static void main(String[] args) {
        new Student(); // new对象，自动执行：构造代码块 → 构造方法
    }
}
// 运行结果：
// 构造代码块执行了
// 构造方法执行了
```

**✔️ ③ 静态代码块 —— 重中之重：类加载时「自动执行，只执行一次」**
定义：写在 类里、所有方法外面 的 static {} 代码块，加了 static 修饰，就是静态代码块；

执行时机：类一加载，立刻执行，而且整个程序运行期间，只执行一次；

优先级：所有代码块里最高的，早于构造代码块、构造方法、普通代码块；

核心作用：初始化静态变量、加载全局的静态资源（比如加载配置文件、初始化工具类），因为只执行一次，效率极高；

```java
public class Student {
    static String className;
    // 静态代码块 ✔️ 优先级最高
    static {
        className = "一班";
        System.out.println("静态代码块执行了");
    }
    // 构造代码块
    {
        System.out.println("构造代码块执行了");
    }
    // 构造方法
    public Student() {
        System.out.println("构造方法执行了");
    }
    public static void main(String[] args) {
        System.out.println("main方法开始");
        new Student(); // 第一次new对象
        new Student(); // 第二次new对象
    }
}
```